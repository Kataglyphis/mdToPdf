\documentclass[aspectratio=169,handout]{beamer}

\makeatletter
\appto\input@path{{../libs/awesome-beamer}, {../libs/smile}}
\makeatother

\definecolor{dred}{HTML}{501613}
\usetheme[english, color, coloraccent=dred, secslide, listings, footnote]{awesome}

\lstdefinelanguage{ts}{
	keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
	ndkeywords={get, number, class, export, boolean, throw, implements, import, this},
	sensitive=false,
	comment=[l]{//},
	morecomment=[s]{/*}{*/},
	morestring=[b]',
	morestring=[b]"
}

\usepackage[
	backend=biber,
	style=alphabetic
]{biblatex}
\usepackage[strict,autostyle]{csquotes}
\nocite{*}
\addbibresource{refs.bib}

\usepackage{fontawesome5}
\def\ergo{\raisebox{.5pt}{\scalebox{.8}{\faCaretRight}}}

\usepackage{contour}
\usepackage{tikzducks}

\usepackage{fontspec}
\setsansfont[
	Ligatures=TeX,
	BoldFont={* Medium},
]{Fira Sans}
\setmonofont[
	Path = ./fonts/,
	Scale = .9,
	Extension = .ttf,
	Contextuals=Alternate,
	BoldFont={*-Bold},
	UprightFont={*-Regular},
]{Fira Code}

\usepackage[duration=90,defaulttransition=fade,enduserslide=43]{pdfpc}
\newcommand<>{\talknote}[1]{\only#2{\pdfpcnote{- #1}\relax}}

\def\link #1 to #2;{\def\ULdepth{.5pt}\def\ULthickness{.1pt}\uline{\href{#2}{#1}}}

\usetikzlibrary{tikzmark,shapes.symbols,decorations.pathmorphing}
\def\m#1{\tikzmark{#1}}
\newcommand<>\ul[5][0pt]{\begin{tikzpicture}[o,blend mode=multiply]
	\coordinate(#5_west) at ([yshift=#1-0.25ex]pic cs:#3);
	\coordinate(#5_east) at ([yshift=#1+0.35ex]pic cs:#4);
	\fill[ul=#2,visible on=#6] (#5_west) rectangle node(#5){} (#5_east);
\end{tikzpicture}}
\tikzset{ul/.style={#1!70!black,opacity=0.40,rounded corners=.17ex}}
\newcounter{ulcntr}\setcounter{ulcntr}{0}
\newcommand<>\doul[2]{%
	\m{uls\theulcntr}#2\m{ule\theulcntr}%
	\ul<#3>{#1}{uls\theulcntr}{ule\theulcntr}{}%
	\stepcounter{ulcntr}%
}

\tikzset{bb/.style={draw=tcbcolframe,dash pattern=on 1mm off 1mm,dash phase=0.5mm,tcb@spec,segmentation@style}}
\def\setlinetext#1{\small\color{tcbcolframe}\contourlength{1.5pt}\contour{tcbcolback}{#1}}
\renewenvironment{block}[1][]{%
	\begin{beamerbox}[segmentation code={
		\path[bb] (segmentation.west) to node{\setlinetext{#1}} (segmentation.east);
	}]{gray}{}%
}{\end{beamerbox}}
\newenvironment{sblock}[1][]{
	\begin{beamerbox}[sidebyside,segmentation code={
		\path[bb] (segmentation.north) to node[rotate=90]{\setlinetext{#1}} (segmentation.south);
	}]{gray}{}%
}{\end{beamerbox}}

\usepackage{emoji}

\usepackage[verbatim]{lstfiracode}
\lstdefinestyle{firastyleb}{style=FiraCodeStyle,style=smile@lst@base}
\lstdefinestyle{firastylep}{style=FiraCodeStyle,style=smile@lst@plain}
\lstset{
	tabsize=4,
	style=firastylep,
	%apptoliterate={{=> }{{{=> }}}3} % for whatever reason, the space would otherwise be eaten
}
\lstdefinelanguage{myhaskell}{
	language=haskell,
	morekeywords={MonadReader,Getting,ASetter,Lens},
}
\newcommand\hn[2][]{\lstinline[language=myhaskell,#1]{#2}}
\def\inlineblock#1{\tikz[anchor=base,baseline]\node[inner sep=0.3333em,rnd,fill=lightgray!50,anchor=base,baseline=] {#1};}
\newcommand\h[2][]{\inlineblock{\hn[#1]{#2}}}
\makeatletter
\lstnewenvironment{haskell}{\lstset{language=myhaskell}}{}
\lstnewenvironment{xshaskell}{\lstset{language=myhaskell,basicstyle=\smile@lst@style@base\footnotesize}}{}
\lstnewenvironment{xxshaskell}{\lstset{language=myhaskell,basicstyle=\smile@lst@style@base\tiny}}{}
\def\inpuths #1 from #2 to #3;{\lstinputlisting[language=myhaskell,firstline=#2,lastline=#3]{#1}}
\def\inputhsxs #1 from #2 to #3;{\lstinputlisting[language=myhaskell,firstline=#2,lastline=#3,basicstyle=\smile@lst@style@base\footnotesize]{#1}}
\def\inputhsxxs #1 from #2 to #3;{\lstinputlisting[language=myhaskell,firstline=#2,lastline=#3,basicstyle=\smile@lst@style@base\tiny]{#1}}
\makeatother

\background{background.jpg}
\title{Lenses}
\subtitle{Functional Programming II}
\author{Lukas Pietzschmann}
\email{lukas.pietzschmann@uni-ulm.de}
\institute{Institute of Software Engineering and Programming Languages}
\uni{Ulm University}
\location{Ulm}
\date{May 13$^\text{th}$, 2024}

\addtobeamertemplate{title page}{}{
\tikz[o]\node[anchor=south east,outer sep=0pt] at (current page.south east)
{\fontsize{4}{4}\selectfont\color{white}This image was generated by AI (DALLE 3)};
}

\usepackage{multicol}

\begin{document}
\maketitle

\makeatletter
\newcommand*{\rom}[1]{\expandafter\@slowromancap\romannumeral #1@}
\makeatother
\newcommand<>\goal[4][]{\begin{visibleenv}#5\begin{tikzpicture}[node distance=.75ex]
	\node[text width=0.43\textwidth,align=left] (H) {\color{accent}\bfseries#3};
	\node[text width=0.43\textwidth,align=left,below=of H.south west,anchor=north west] (D) {#4};
	\node[roundednode,fit=(H)(D),node on layer=background,shadow,draw=none,fill=gray!20] (F) {};
	\node[anchor=north east,on layer=background,opacity=0.15] at (F.north east) {\Huge\color{accent}\bfseries\MakeUppercase{\rom{#2}}};
	\if\isempty{#1}\else\begin{scope}[transparency group,opacity=0.7]
		\draw[draw=red,lcr,line width=1ex,visible on=<#1>] (F.north west) -- (F.south east);
		\draw[draw=red,lcr,line width=1ex,visible on=<#1>] (F.south west) -- (F.north east);
	\end{scope}\fi
\end{tikzpicture}\par\bigskip\end{visibleenv}}
\begin{frame}[wide]
	\frametitle{Learning Objectives}
	\begin{wide}
	\begin{multicols}{2}
		\goal<2->{1}{Why do we need lenses?}{Understand where the idea of lenses come from, and how
			one could have come up with them.}
		\goal<3->{2}{How can I use them?}{Know the basic functions and operators and know how to
			discover new ones.}
		\goal<4->{3}{What else is there?}{Know of other lens-like abstractions, why we
			presumably need them, and how they differ.}
		\goal<5->[6-]{4}{WTF are those types?}{Understand the ins and outs of the lens package and
			every type.}
	\end{multicols}
	\end{wide}
\end{frame}

\section{What}

\colorlet{m}{blue!45!black}
\tikzset{q/.style={chamfered rectangle,draw,lw,chamfered rectangle xsep=2cm,fill=m,text=white}}
\tikzset{qa/.style={q,text width=0.4\textwidth}}
\def\qn#1{\textcolor{orange!80!black}{\textbf{#1}}}
\begingroup
\colorlet{accent}{m}
\makeatletter\smile@listings@initcolors\makeatother
\setbeamercolor{footline}{fg=white,bg=m}
\setbeamercolor{footlineright}{fg=white,bg=m}
\begin{frame}[t,fragile]
	\frametitle{What are lenses}
	\begin{wide}\vspace{5mm}
		\begin{haskell}
			type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
		\end{haskell}
		\begin{visibleenv}<2->
		\begin{tikzpicture}[o,node distance=.5ex]
			\draw[draw=none,top color=white,bottom color=m] (current page.west) rectangle ([yshift=1.8ex]current page.south east);

			\node[q] at ([yshift=-5mm]current page) (Q) {What is the purpose of a lens, according to the types above?};
			\coordinate (AS) at ([yshift=-1.3cm]Q.south);

			\node[qa,left=of AS,left,muted on=<3-|handout:2->] (A) {\scriptsize\qn{A:} A package for creating visualizations};
			\node[qa,right=of AS,right] (B) {\scriptsize\qn{B:} A tool for handling nested ADTs};

			\node[qa,below=of A,muted on=<3-|handout:2->] (C) {\scriptsize\qn{C:} A framework for building UIs};
			\node[qa,below=of B,muted on=<3-|handout:2->] (D) {\scriptsize\qn{D:} A package for simulating optical lenses};

			\draw[lw,short=-1pt,muted on=<3-|handout:2->] (A.east) to (B.west);
			\draw[lw,short=-1pt,muted on=<3-|handout:2->] (C.east) to (D.west);

			\draw[lw,short=-1pt] (Q.west) to (Q.west -| current page.west);
			\draw[lw,short=-1pt] (Q.east) to (Q.east -| current page.east);

			\draw[lw,short=-1pt,muted on=<3-|handout:2->] (A.west) to (A.west -| current page.west);
			\draw[lw,short=-1pt,muted on=<3-|handout:2->] (C.west) to (C.west -| current page.west);
			\draw[lw,short=-1pt,muted on=<3-|handout:2->] (B.east) to (B.east -| current page.east);
			\draw[lw,short=-1pt,muted on=<3-|handout:2->] (D.east) to (D.east -| current page.east);
		\end{tikzpicture}
		\end{visibleenv}
	\end{wide}
	\begin{modal}<4|handout:3>
		\begin{quote}
			In Haskell, types provide a pretty good explanation of what a function does. Good luck deciphering lens types.
		\end{quote}\par
		\hfill Roman Cheplyaka
	\end{modal}
\end{frame}
\endgroup

\begin{frame}
	\frametitle{What are lenses}
	\uncover<2->{Well, \enquote{lens} is also a \link package to https://hackage.haskell.org/package/lens;}
	\uncover<3->{\ldots{} Here are some random functions and operators from that package:\bigskip}
	\begin{visibleenv}<4->
	\begin{center}
		\begin{tabular}{lcl}
		\hline
		\hn{view} & \hn{_1}  & \hn{allOf}    \\ \hline
		\hn{set}  & \hn{^.}  & \hn{anyOf}    \\ \hline
		\hn{over} & \hn{^?!} & \hn{concatOf} \\ \hline
		\end{tabular}
	\end{center}\bigskip
	\end{visibleenv}
	\uncover<5->{We'll shortly see what they do and how we can use them.}
\end{frame}

\section{Why}

\begin{frame}[fragile]
	\frametitle{Why do we need them}
	\onslide<2->%
	Imagine you want to parse configuration files in Haskell. To model them, you come up
	with the following ADTs:\par\medskip
	\onslide<3->%
	\begin{haskell}
data File = File {
  name    :: String,
  entries :: [Entry]
}
§\onslide<4->§data Entry = Entry {
  key   :: String,
  value :: Value
}
§\onslide<5->§data Value = Value {
  curr :: String,
  def  :: String
}
	\end{haskell}
\end{frame}

\begin{frame}
	\frametitle{Why do we need them}
	\onslide<2->%
	Let's say we parsed a file into the following configuration:\bigskip
	\onslide<3->%
	\inpuths examples/example.hs from 24 to 28;\bigskip
	\onslide<4->%
	Cool, isn't it. Now we want to work with this representation.
\end{frame}

\begin{frame}[fragile]
	\frametitle{Why do we need them}
	\begin{haskell}
		§\onslide<2->§getEntry :: String -> File -> Entry
		§\onslide<6->§getEntry k = §\onslide<5->§head . §\onslide<4->§filter ((==) k . key) . §\onslide<3->§entries

		§\onslide<7->§getCurrentValue :: Entry -> String
		§\onslide<10->§getCurrentValue = §\onslide<9->§curr . §\onslide<8->§value

		§\onslide<11->§setCurrentValue :: String -> Entry -> Entry
		§\onslide<12->§setCurrentValue newValue entry = entry {
			value = (value entry) {
				curr = newValue
			}
		}
	\end{haskell}\medskip
	\onslide<13->Oof, this sucks. And it get's even worse the deeper the ADT gets!
	\onslide<1->\begin{tikzpicture}[o]
		\node[anchor=west,xshift=2mm,rnd,fill=gray!20,shadow] at (current page.west) (A) {
			\inputhsxxs examples/example.hs from 1 to 12;
		};
	\end{tikzpicture}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Let's reinvent the lens}
	\onslide<2->Let's see, if we can improve this by adding some modifier
	functions:\makeatletter\medskip
	\begin{xshaskell}
		§\onslide<3->§modifyCurrentValue :: (String -> String) -> Value -> Value
		§\onslide<4->§modifyCurrentValue f value = value {
			§\onslide<5->§curr = f $ curr value
		§\onslide<4->§}

		§\onslide<3->§modifyEntriesValue :: (Value -> Value) -> Entry -> Entry
		§\onslide<6->§modifyEntriesValue f entry = entry {
			§\onslide<7->§value = f $ value entry
		§\onslide<6->§}

		§\onslide<3->§modifyEntriesCurrentValue :: (String -> String) -> Entry -> Entry
		§\onslide<10->§modifyEntriesCurrentValue = §\onslide<9->§modifyEntriesValue . §\onslide<8->§modifyCurrentValue
	\end{xshaskell}
	\onslide<1->\begin{tikzpicture}[o]
		\node[anchor=west,xshift=2mm,rnd,fill=gray!20,shadow] at (current page.west) (A) {
			\inputhsxxs examples/example.hs from 1 to 12;
		};
	\end{tikzpicture}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Let's reinvent the lens}
	\onslide<2->We can use our modify-functions to implement a setter:
	\begin{haskell}
		§\onslide<3->§setCurrentValue' :: String -> Entry -> Entry
		§\onslide<4->§setCurrentValue' = modifyEntriesCurrentValue§\onslide<5->§ . const
	\end{haskell}\bigskip\onslide<6->

	The getter is still fine:
	\begin{haskell}
		§\onslide<7->§getCurrentValue' :: Entry -> String
		§\onslide<10->§getCurrentValue' = §\onslide<9->§def . §\onslide<8->§value
	\end{haskell}\bigskip
	\onslide<1->\begin{tikzpicture}[o]
		\node[anchor=west,xshift=2mm,rnd,fill=gray!20,shadow] at (current page.west) (A) {
			\inputhsxxs examples/example.hs from 1 to 12;
		};
	\end{tikzpicture}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Let's reinvent the lens}
	\onslide<2->Now, we can build our lens abstraction:
	\begin{xshaskell}
		§\onslide<3->§data Lens s a = Lens {
			§\onslide<4->§get :: s -> a,
			§\onslide<5->§modify :: (a -> a) -> s -> s
		§\onslide<3->§}
	\end{xshaskell}\medskip

	\onslide<6->We need to reimplement the function composition:
	\begin{xshaskell}
		§\onslide<7->§compose :: Lens a b -> Lens b c -> Lens a c
		§\onslide<8->§compose (Lens g m) (Lens g' m') = Lens {
			§\onslide<9->§get = g' . g,
			§\onslide<10->§modify = m . m'
		§\onslide<8->§}
	\end{xshaskell}\medskip

	\onslide<11->For easier handling, we also define \h{set} as a little helper:
	\begin{xshaskell}
		§\onslide<12->§set :: Lens s a -> a -> s -> s
		§\onslide<13->§set (Lens _ modify) = modify§\onslide<14->§ . const
	\end{xshaskell}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Let's reinvent the lens}
	\onslide<2->Finally, we can build lenses for our ADTs:\makeatletter\medskip
	\begin{xshaskell}
		§\onslide<3->§currentValueL :: Lens Value String
		§\onslide<4->§currentValueL = Lens {
			§\onslide<5->§get = curr,
			§\onslide<6->§modify = \f value -> value { curr = f $ curr value }
		§\onslide<4->§}

		§\onslide<7->§entryValueL :: Lens Entry Value
		§\onslide<8->§entryValueL = Lens {
			§\onslide<9->§get = value,
			§\onslide<10->§modify = \f entry -> entry { value = f $ value entry }
		§\onslide<8->§}

		§\onslide<11->§entryCurrentValueL :: Lens Entry String
		§\onslide<12->§entryCurrentValueL = entryValueL§\onslide<13->§ `compose` currentValueL
	\end{xshaskell}
	\onslide<1->\begin{tikzpicture}[o]
		\node[anchor=west,xshift=2mm,rnd,fill=gray!20,shadow] at (current page.west) (A) {
			\begin{xxshaskell}
data File = File {
  name    :: String,
  entries :: [Entry]
}
data Entry = Entry {
  key   :: String,
  value :: Value
}
data Value = Value {
  curr :: String,
  def  :: String
}
data Lens s a = Lens {
  get :: s -> a,
  modify ::
    (a->a) -> s -> s
}
			\end{xxshaskell}
		};
	\end{tikzpicture}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Let's reinvent the lens}
	\onslide<2->Now we only have to plug our lens into \h{set}, \h{get}, or \h{modify}:
	\begin{haskell}
		§\onslide<3->§setCurrentValue'' :: String -> Entry -> Entry
		§\onslide<4->§setCurrentValue'' = set §\onslide<5->§entryCurrentValueL

		§\onslide<6->§getCurrentValue'' :: Entry -> String
		§\onslide<7->§getCurrentValue'' = get §\onslide<8->§entryCurrentValueL
	\end{haskell}
\end{frame}

% \begin{frame}
% 	\frametitle{Let's reinvent the lens}
% 	\color{red}\bfseries Play GHC and evaluate an expression step by step
% \end{frame}

\begin{frame}[fragile]
	\frametitle{Let's reinvent the lens}
	\onslide<2->Puh, that was kinda complicated. But again, think of how much less code you have to
	write:\par
	\onslide<3->\begin{sblock}[versus]
		\begin{haskell}
			let f = _foo v
				b = _bar f
				z = _baz b in
			v { _foo = f {
					_bar = b {
						_baz = z + 1
					} } }
		\end{haskell}
		\tcblower
		\begin{visibleenv}<4->
		\begin{haskell}
			v & foo . bar . baz +~ 1
		\end{haskell}
		\end{visibleenv}
	\end{sblock}
	\onslide<5->We can now think \enquote{How can I traverse through this?} instead of \enquote{How do
	I un- and repack all of this?}.
\end{frame}

\begin{frame}[fragile]
	\frametitle{Let's reinvent the lens}
	\onslide<2->Our solution looks more flexible than what we had before. But there are still some
	problems:\bigskip
	\begin{itemize}[<+(2)->]
		\item Still feels a bit clunky and boilerplate-heavy
		\item We always have to create \h{Lens} values
		\item No support for polymorphic updates
	\end{itemize}\bigskip
	\onslide<8->It's definitely not impossible to overcome these limitations, but we'll skip this
	for now.
	\onslide<1->\begin{modal}<6|handout:2>[\footnotesize Polymorphic Update]
		\begin{haskell}
			data Pair a b = Pair {e1 :: a, e2 :: b}

			p :: Pair Int String
			p = Pair 420 "is fun"

			p { e1 = "FP" }  §\ergo\texttt{~~~Pair \{ e1 = "FP", e2 = "is fun" \}}§
		\end{haskell}\bigskip
		\ergo{} Notice that the type has changed from \h{Pair Int String} to \h{Pair
		String String}. This is what we call \emph{polymorphic update}.
	\end{modal}
\end{frame}

\begin{frame}
	\frametitle[Revisited]{What are lenses}
	\onslide<2->Lenses are:
	\begin{itemize}[<+(2)->]
		\item A way to \emph{focus} on a part of a data structure
	\end{itemize}\bigskip
	\onslide<4->Or more precisely:
	\begin{itemize}[<+(3)->]
		\item Just another abstraction
		\item Functional references
		\item Getters and Setters
		\item Highly composable  and flexible
			\begin{itemize}
				\item \enquote{The Power is in the Dot}\quad\textcolor{gray}{Edward Kmett}
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle[\cite{lenshist}]{A little history lesson}
	\begin{itemize}[<+(1)->]\setlength\itemsep{.7em}
		% \item[\tikzmark{a}] Jeremy Gibbons and Bruno Oliveira demonstrate that
		% 	Traversals encode the Iterator pattern~\cite{gibbons2009}
		\item[\tikzmark{b}] Luke Palmer creates a pattern he calls \emph{Accessors} to
			ease stateful programming in Haskell~\cite{palmer2007game}. He uses C's
			preprocessor to generate \h{readVal} and \h{writeVal} functions.\footnote{In
			another blog post he then swaps out the preprocessor in favour of Template
			Haskell.}
		\item[\tikzmark{c}] Palmer generalizes his Accessors into something more like
			today's lenses.~\cite{palmer2007acc}
		\item[\tikzmark{d}] Twan van Laarhoven comes up with a novel way to express
			lenses using the \h{Functor} class~\cite{laarhoven2009}. We call them
			\emph{van Laarhoven lenses}.
	\end{itemize}
	\begin{tikzpicture}[remember picture,overlay]
		\coordinate (S) at ([shift={(-2mm,1.5mm)}]pic cs:b);
		\coordinate (E) at ([shift={(-2mm,0cm)}]pic cs:d);
		\draw[lw] (S) -- (E);
		\draw[dashed,lw] (E) -- ([yshift=-1cm]E);
		\node[roundnode,fill=accent,draw=accent,inner sep=1.5pt,visible on=<2->] at (S) {};
		% \node[roundnode,fill=accent,draw=accent,inner sep=1.5pt,visible on=<5->] at ([shift={(-2mm,1.5mm)}]pic cs:b) {};
		\node[roundnode,fill=accent,draw=accent,inner sep=1.5pt,visible on=<3->] at ([shift={(-2mm,1.5mm)}]pic cs:c) {};
		\node[roundnode,fill=accent,draw=accent,inner sep=1.5pt,visible on=<4->] at ([shift={(-2mm,1.5mm)}]pic cs:d) {};
	\end{tikzpicture}
\end{frame}

\begin{frame}
	\frametitle[\cite{lenshist}]{A little history lesson}
	\begin{itemize}[<+(1)->]\setlength\itemsep{.7em}
		\item[\tikzmark{e}] Russell O'Connor realises van Laarhoven lenses have always
			supported polymorphic updates.~\cite{connor2012}
		\item[\tikzmark{f}] Edward Kmett realises that you can put laws on the notion of
			polymorphic updates.~\cite{kmett2012}
		\item[\tikzmark{g}] Kmett pushed the \link first commit to
			https://github.com/ekmett/lens/commit/c5c8e5ffeeccdd7ac78f758dfc5723c411443d78;
			to the lens repository on \link GitHub to https://github.com/ekmett/lens;
	\end{itemize}
	\begin{tikzpicture}[remember picture,overlay]
		\coordinate (S) at ([shift={(-2mm,1.5mm)}]pic cs:e);
		\coordinate (E) at ([shift={(-2mm,-1.1cm)}]pic cs:g);
		\draw[dashed,lw] ([yshift=7.5mm]S) -- (S);
		\draw[-{Latex[round,accent]},lw] (S) -- (E);
		\node[roundnode,fill=accent,draw=accent,inner sep=1.5pt,visible on=<2->] at (S) {};
		\node[roundnode,fill=accent,draw=accent,inner sep=1.5pt,visible on=<3->] at ([shift={(-2mm,1.5mm)}]pic cs:f) {};
		\node[roundnode,fill=accent,draw=accent,inner sep=1.5pt,visible on=<4->] at ([shift={(-2mm,1.5mm)}]pic cs:g) {};
	\end{tikzpicture}
\end{frame}

\section{How}
\subsection{A little Overview}

\begin{frame}
	\frametitle{A little Overview}
	\onslide<2->Lenses basically provide two kinds of operations:
	\begin{itemize}[<+(2)->]
		\item \hn{view :: Lens' s a -> s -> a}
		\item \hn{set :: Lens' s a -> a -> s -> s}
	\end{itemize}\medskip\onslide<5->
	To use them, we need the actual lens. It determines what part of the structure
	we want to focus on.
	\begin{itemize}[<+(3)->]
		\item \hn{_1 :: Lens' (a,b) a}
		\item \hn{_2 :: Lens' (a,b) b}
	\end{itemize}\medskip\onslide<8->
	With all that in place, we can now combine the operation with a lens (or a
	combination of lenses) and data:
	\begin{itemize}
		\item<9-> \hn{set _2 "cool" ("FP is", "")}\onslide<10->\kern8pt\ergo\kern8pt\hn{("FP is", "cool")}
		\item<11-> \hn{view _1 ("hi", "there")}\onslide<12->\kern8pt\ergo\kern8pt\hn{"hi"}
		% \item \doul{red}{\hn{set}} \doul{blue}{\hn{_2}} \doul{green}{\hn{"cool"}} \doul{green}{\hn{("FP is", "")}}\kern8pt\ergo\kern8pt\hn{("FP is", "cool")}
		% \item \doul{red}{\hn{view}} \doul{blue}{\hn{_1}} \doul{green}{\hn{("hi", "there")}}\kern8pt\ergo\kern8pt\hn{"hi"}
	\end{itemize}%
\end{frame}

\subsection{Lens Laws}

\begin{frame}
	\frametitle{Lens Laws}
	\onslide<2->Like with functors, applicatives, and monads, lenses \emph{should} follow some
	rules:
	\begin{enumerate}[<+(2)->]
		\item Get-Put
		\item Put-Get
		\item[\emoji{hatching-chick}] Put-Put
	\end{enumerate}
	\onslide<6->We'll look at them in a bit more detail.
\end{frame}

\begin{frame}[fragile]
	\frametitle[Get-Put]{Lens Laws}
	\onslide<2->If you modify something by changing its subpart to exactly what it was before,
	nothing should happen.\bigskip
	\onslide<3->\begin{haskell}
		set entryValueL (get entryValueL entry) entry == entry
	\end{haskell}\bigskip
	\onslide<4->\ergo{} The lens should not modify the value or structure by itself.
\end{frame}

\begin{frame}[fragile]
	\frametitle[Put-Get]{Lens Laws}
	\onslide<2->If you modify something by inserting a particular subpart and then view the result,
	you'll get back exactly that subpart.\bigskip
	\onslide<3->\begin{haskell}
		get entryValueL (set entryValueL v entry) == v
	\end{haskell}\bigskip
	\onslide<4->\ergo{} Setting values should be independent of any previous state.
\end{frame}

\begin{frame}[fragile]
	\frametitle[Put-Put]{Lens Laws}
	\onslide<2->If you modify something by inserting a particular subpart \h{a}, and then modify it
	again inserting a different subpart \h{b}, it's exactly as if you only did the
	second insertion.\bigskip
	\onslide<3->\begin{haskell}
		set entryValueL v2 (set entryValueL v1 entry) == set entryValueL v2 entry = 1
	\end{haskell}\bigskip
	\onslide<4->\ergo{} Previous updates should not leave any traces.
\end{frame}

\begin{frame}
	\frametitle{Do I really have to follow them?}
	\begin{itemize}[<+(1)->]
		\item Yes, you should! Otherwise your lenses might behave weird.
		\item And weird unpredictable things are for OOP \emoji{wink}
	\end{itemize}\bigskip
	\begin{itemize}[<+(1)->]
		\item But, we can get around them
		\item In fact, we can get around the whole process of creating a lens by
			hand
		\item You remember Template-Haskell, do you?
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Do I really have to follow them?}
	\begin{haskell}
		§\onslide<2->§{-# LANGUAGE TemplateHaskell #-}

		§\onslide<3->§import Control.Lens

		§\onslide<4->§data File  = File  {_name :: String, _entries :: [Entry]}
		§\onslide<4->§data Entry = Entry {_key  :: String, _value   :: Value  }
		§\onslide<4->§data Value = Value {_curr :: String, _def     :: String }

		§\onslide<5->§makeLenses ''File
		§\onslide<5->§makeLenses ''Entry
		§\onslide<5->§makeLenses ''Value
	\end{haskell}
\end{frame}

\subsection{The actual Package}

\begin{frame}
	\frametitle{The lens Package}
	\begin{itemize}[<+(1)->]
		\item Until now, we have only used \h{view} and \h{set}
		\item But there are actually a lot more functions and operators
		\item I mean a loooooooooooooooooot; easily over 100
	\end{itemize}\bigskip
	\begin{itemize}
		\item<5-> Let's try to find a pattern in their names
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{The lens Package}
	\begin{wide}
	\begin{columns}[c]
		\begin{column}<2->{0.45\textwidth}
			\begin{block}
			Operators beginning with \h{^} behave like \h{view} functions:
			\begin{haskell}
				§\onslide<3->§Value "c" "d" ^. def §\onslide<4->\ergo~\texttt{"d"}§
				§\onslide<5->§(1,2) ^.. both §\onslide<6->\ergo~\texttt{[1,2]}§
				§\onslide<7->§Right 42 ^? _Left §\onslide<8->\ergo~\texttt{Nothing}§
			\end{haskell}
			\end{block}
		\end{column}
		\begin{column}<9->{0.45\textwidth}
			\begin{block}
			Operators ending in \inlineblock{\string~\rlap{\phantom{t}}} behave like \h{set} functions:
			\begin{haskell}
				§\onslide<10->§(_2 .~ 3) (0, 0) §\onslide<11->\ergo~\texttt{(0,3)}§
				§\onslide<12->§(_2 +~ 3) (0, 39) §\onslide<13->\ergo~\texttt{(0,42)}§
				§\onslide<14->§(_1 %~ (+1)) (3,2) §\onslide<15->\ergo~\texttt{(4,2)}\onslide<1->§
			\end{haskell}
			\end{block}
		\end{column}
	\end{columns}\bigskip
	\onslide<16->Writing \h{lens .~ value $ adt} every time is not very nice. \onslide<17->But as always, there's
	a special operator to our rescue: \h{& :: a -> (a -> b) -> b}.
	\end{wide}
\end{frame}

\begin{frame}[fragile]
	\frametitle{The lens Package}
	\onslide<2->With this knowledge aquired, we can finally write concise Haskell-code:\par\medskip
	\begin{haskell}
		§\onslide<6->§(6, 2) & §\onslide<4->§both §\onslide<3->§*~ §\onslide<5->§7 §\onslide<7->\ergo~\texttt{(42, 14)}§
	\end{haskell}\medskip
	\begin{haskell}
		§\onslide<8->§lens = §\onslide<9->§entries §\onslide<10->§. _last§\onslide<11->§ . value§\onslide<12->§ . curr
		§\onslide<13->§val =§\onslide<15->§ config§\onslide<14->§ ^?!§\onslide<16->§ lens §\onslide<17->\ergo~\texttt{"88"} §
		§\onslide<21->§config &§\onslide<19->§ lens §\onslide<18->§.~ §\onslide<20->§val ++ "0" §\onslide<22->\ergo~\texttt{curr = "880" \color{gray}inside config}§
		§\onslide<23->§over §\onslide<24->§lens §\onslide<25->§(++"0")§\onslide<26->§ config §\onslide<27->\ergo~\texttt{curr = "880" \color{gray}inside config}§
	\end{haskell}\medskip\onslide<28->
	\begin{haskell}
		(0, "upd.") & _1 .~ "poly." §\onslide<29->\ergo~\texttt{("poly.", "upd.")}§
	\end{haskell}\onslide<1->
	\begin{tikzpicture}[o]
		\node[anchor=west,xshift=7mm,rnd,fill=gray!20,shadow] at (current page.west) (A) {
			\rotatebox{90}{\inputhsxxs examples/example.hs from 24 to 28;}
		};
	\end{tikzpicture}
\end{frame}

% \begin{frame}
% 	\frametitle{The lens Package}
% 	\begin{description}
% 		\item[\h{view}] \h{v ^. l}
% 		\item[\h{set}] \h{v & l .~ x}
% 		\item[\h{set Just}] \h{v & l ?~ mx}
% 		\item[\h{incr}] \h{v & l +~ n}
% 		\item[\h{append}] \h{v & l <>~ x}
% 	\end{description}
% \end{frame}

\tikzset{b/.style={arrow,short=1mm,draw=green}}
\tikzset{c/.style={arrow,short=1mm,draw=lightgray,dashed}}
\begin{frame}
	\frametitle[Gotchas]{The lens Package}
	\onslide<2->You might have notices that lenses compose backwards:\par\onslide<1->
	\begin{center}
	\begin{tikzpicture}[node distance=7mm]
		\onslide<3->\node[roundednode,draw=none,shadow,fill=gray!20] (A) {\strut\hn{entries}};
		\onslide<4->\node[roundednode,draw=none,shadow,fill=gray!20,right=of A] (B) {\strut\hn{_last}};
		\onslide<5->\node[roundednode,draw=none,shadow,fill=gray!20,right=of B] (C) {\strut\hn{value}};
		\onslide<6->\node[roundednode,draw=none,shadow,fill=gray!20,right=of C] (D) {\strut\hn{curr}};
		\onslide<1->\node[left=of A] (AA) {};
		\node[right=of D] (DD) {};

		\begin{scope}[transform canvas={yshift=1.2mm}]
			\draw[b,visible on=<12->] (AA) to (A);
			\draw[b,visible on=<13->] (A) to (B);
			\draw[b,visible on=<14->] (B) to (C);
			\draw[b,visible on=<15->] (C) to (D);
			\draw[b,visible on=<16->] (D) to (DD);
		\end{scope}

		\begin{scope}[transform canvas={yshift=-1.2mm}]
			\draw[c,visible on=<7->] (DD) to (D);
			\draw[c,visible on=<8->] (D) to (C);
			\draw[c,visible on=<9->] (C) to (B);
			\draw[c,visible on=<10->] (B) to (A);
			\draw[c,visible on=<11->] (A) to (AA);
		\end{scope}

		\coordinate (X) at ($(B)!.5!(C)$);
		\node[above=of X,yshift=-2mm,visible on=<12->] {\small\color{green}lens};
		\node[below=of X,yshift=2mm,visible on=<7->] {\small\color{lightgray}Haskell};
	\end{tikzpicture}
	\end{center}\par
	\onslide<17->This makes it weird for FP-enjoyers, but intuitive for OOP-weirdos.\par
	\onslide<20->The same applies for all kinds of operators:\par
	\onslide<21->\begin{center}
		\begin{tabular}{c|c}
			lens & Haskell\\
			\hline\hline
			\hn{5 & (+1)} & \hn{(+1) $ 5}\\
			\hn{Just 5 <&> (+1)} & \hn{(+1) <$> (Just 5)}\\
		\end{tabular}
	\end{center}\onslide<1->
	\begin{modal}<18|handout:2>
		\begin{quote}
			Backward composition of lenses. It’s a minor issue, and I wouldn’t mention
			it if it wasn’t a great demonstration of how lens goes against the
			conventions of Haskell.
		\end{quote}\par
		\hfill Roman Cheplyaka
	\end{modal}
\end{frame}

\begin{frame}
	\frametitle[Getters]{The lens Package}
	\onslide<2->Writing a \emph{Getter} is really easy. We can simply promote any \emph{function} or
	\emph{value} to a Getter.\par\bigskip
	\begin{itemize}[<+(2)->]\setlength\itemsep{10pt}
		\item \h{to} builds a Getter from any function\par\medskip
			\hn{("Hello", "FP2") ^. to snd}\quad\ergo\quad\hn{"FP2"}
		\item \h{like} always returns a constant value\par\medskip
			\hn{("Hello", "FP2") ^. like 42}\quad\ergo\quad\hn{42}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle[Setters]{The lens Package}
	\onslide<2->Writing a \emph{Setter} is only slightly more complicated, as we don't set the value
	directly, but apply a function on the focused part.\par\bigskip
	\begin{itemize}[<+(2)->]\setlength\itemsep{10pt}
		\item \h{setting} receives a function, that applies another function to the
			correct value inside a structure\par\medskip
			\hn{(4,1) & setting (\\f (x,y) -> (x,f y)) .~ 2}\quad\ergo\quad\hn{(4,2)}
		\item \h{sets} is in theory a bit more flexible, but that's out of scope for
			today\par\medskip
			\hn{(4,1) & sets (\\f (x,y) -> (x,f y)) .~ 2}\quad\ergo\quad\hn{(4,2)}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle[Getter + Setter]{The lens Package}
	\onslide<2->Having a separate Getter and Setter is not always desirable. Now, we want to create
	our own lens that we can use as both Getter and Setter. This time, \h{makeLenses}
	doesn't count!\par\bigskip
	\begin{itemize}\setlength\itemsep{10pt}
		\item<3-> We can use \h{lens} to combine a viewing and setting function
			\begin{haskell}
				§\onslide<4->§g = snd
				§\onslide<5->§s = (\(a,_) b -> (a,b))
				§\onslide<6->§_2 = lens g s
			\end{haskell}
		\item<7-> You can also simply write a custom function with the type \h{l :: forall
			f. Functor f => (a -> f b) -> s -> f t} that satisfies all three lens laws.
			Good luck! \onslide<8->We'll try it anyway.
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle[How \texttt{lens} works~\cite{writelens}]{The lens Package}
	\begin{wide}
	\begin{haskell}
		§\onslide<2->§type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
		§\onslide<3->§type Lens' §\m{lensss}§s§\m{lensse}§ §\m{lenses}§a§\m{lensee}§ = Lens s s a a
	\end{haskell}\ul<4->{gray}{lensss}{lensse}{s}\ul<5->{gray}{lenses}{lensee}{a}
	\begin{tikzpicture}[o]
		\node[yshift=-1cm,xshift=5mm,anchor=west,visible on=<4->] at (a) (S) {The type of the whole structure};
		\node[yshift=-5mm,xshift=5mm,anchor=west,visible on=<5->] at (a) (A) {The inner type we're interested in};
		\draw[textarrow,rnd,shorten >=-.2mm,visible on=<4->] (S) -| (s);
		\draw[textarrow,rnd,shorten >=-.2mm,visible on=<5->] (A) -| (a);
	\end{tikzpicture}\bigskip\onslide<6->
	\begin{haskell}
		lens :: Functor f => (s->a) -> (s->a->s) -> (a->f a) -> s -> f s
		lens get set f s = ...
	\end{haskell}\bigskip
	\begin{itemize}
		\item<7-> We need to get from \h{s -> a} and \h{s -> a -> s} to \h{f s}
		\item<8-> We can get an \h{a} from our getter: \h{get s}
		\item<9-> With \h{a} and \h{f} we can make an \h{f a}: \h{f $ get s}
	\end{itemize}
	\end{wide}
\end{frame}

\begin{frame}[fragile]
	\frametitle[How \texttt{lens} works~\cite{writelens}]{The lens Package}
	\begin{wide}
	\begin{haskell}
		lens :: Functor f => (s->a) -> (s->a->s) -> (a->f a) -> s -> f s
		lens get set f s = §\alt<5>{set s <\$> f (get s)}{...}§
	\end{haskell}\bigskip
	\begin{itemize}
		\item We need to get from \h{s -> a} and \h{s -> a -> s} to \h{f s}
		\item We can get an \h{a} from our getter: \h{get s}
		\item With \h{a} and \h{f} we can make an \h{f a}: \h{f $ get s}
		\item<2-> Now, to get an \h{f s}, we an simply use
			\begin{haskell}
				fmap :: Functor f => §\m{ffs}§(a -> b)§\m{ffe}§ -> §\m{fxs}§f a§\m{fxe}§ -> f b
			\end{haskell}\ul<3->{gray}{ffs}{ffe}{f}\ul<4->{gray}{fxs}{fxe}{x}
	\end{itemize}
		\begin{tikzpicture}[o]
			\node[yshift=-9mm,xshift=-3mm,visible on=<3->] at (f) (F) {\hn{set s}};
			\node[yshift=-9mm,xshift=3mm,visible on=<4->] at (x) (X) {\hn{f $ get s}};
			\draw[textarrow,shorten >=-.2mm,shorten <=0mm,visible on=<3->] (F) to (f);
			\draw[textarrow,shorten >=-.2mm,shorten <=-0.5mm,visible on=<4->] (X) to (x);
		\end{tikzpicture}
	\end{wide}
\end{frame}

\section{More Goodies}

\subsection{Virtual lenses}
\begin{frame}[fragile]
	\frametitle{Virtual lenses}
	\onslide<2->A Getter does not always have to be backed by an actual structure. Theoretically, it
	can return \emph{anything}:
	\onslide<3->\begin{lstlisting}[language=ts]
		get virtualProp(): number {
			return 42
		}
	\end{lstlisting}\bigskip
	\onslide<4->We can easily achieve this behavior with lenses, too:
	\begin{haskell}
		§\onslide<5->§virtualProp = like 42
		§\onslide<8->§(0,0) §\onslide<6->§^.§\onslide<7->§ virtualProp §\onslide<9->\ergo~\texttt{42}§
	\end{haskell}
\end{frame}

\subsection{Prisms}

\begin{frame}[fragile]
	\frametitle{Prisms}
	% \begin{sblock}[]
	% 	Lenses reference something that \emph{always} exists.
	% 	\tcblower
	% 	Prisms reference something that \emph{may} exist.
	% \end{sblock}\bigskip
	\onslide<2->So far, we only looked at product types. But what about sum types? Prisms to the
	rescue!\par\bigskip
	\begin{haskell}
§\onslide<3->§data CanteenMeal = MainCourse String CanteenMeal
                 | Desert String

§\onslide<4->§meal1 = MainCourse "Sattmacher" (Desert "Pudding")
§\onslide<5->§meal2 = Desert "Yogurt"

§\onslide<8->§meal1 §\onslide<6->§^?§\onslide<7->§ _MainCourse . _2 . _Dessert §\onslide<9->\ergo~\texttt{Just "Pudding"}§
§\onslide<10->§meal2 ^? _MainCourse . _2 . _Dessert §\onslide<11->\ergo~\texttt{Nothing}§

§\onslide<15->§meal1 &  §\onslide<13->§_MainCourse . _2 . _Dessert §\onslide<12->§.~ §\onslide<14->§"Yogurt"
§\onslide<16->\ergo~\texttt{Desert "Yogurt" \color{gray}inside meal1}§
	\end{haskell}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Prisms}
	\begin{itemize}[<+(1)->]
		\item We already used a prism: remember \h{_last}?
		\item We can usually use them like a normal lens (there's just a little
			\h{Maybe} in the way)
	\end{itemize}\medskip
	\onslide<4->\begin{block}[versus]
		\begin{haskell}
			case meal1 of
				MainCouse _ (Dessert d) -> MainCourse {
					dessert = Dessert "Yogurt" }
				_ -> meal1
		\end{haskell}
		\tcblower
		\onslide<5->{\hn{meal1 &  _MainCourse . _2 . _Dessert .~ "Yogurt"}}
	\end{block}
\end{frame}

\subsection{Traversals}
\newsavebox\wwm
\tikzset{modal box/.append style={align=center,fill=m!20}}
\begin{frame}[fragile]
	\frametitle{Traversals}
	% \begin{columns}[c]
	% 	\begin{column}{0.45\textwidth}
	% 		\begin{block}
	% 		Lenses reference something that \emph{always} exists.
	% 		\end{block}
	% 	\end{column}
	% 	\begin{column}{0.45\textwidth}
	% 		\begin{block}
	% 		Traversals reference \emph{many things} that \emph{may} exist.
	% 		\end{block}
	% 	\end{column}
	% \end{columns}\bigskip
	\savebox\wwm{\begin{tikzpicture}[node distance=.5ex]
		% \draw[draw=none,top color=white,bottom color=m] (current page.west) rectangle ([yshift=1.8ex]current page.south east);

		\node[q] at ([yshift=-5mm]current page) (Q) {What do you think will \texttt{["a","b"] \textasciicircum. traverse} return?};
		\coordinate (AS) at ([yshift=-1.3cm]Q.south);

		\node[qa,left=of AS,left] (A) {\scriptsize\qn{A:} \texttt{["a","b"]}};
		\node[qa,right=of AS,right] (B) {\scriptsize\qn{B:} \texttt{"a"}};

		\node[qa,below=of A] (C) {\scriptsize\qn{C:} \texttt{"ab"}};
		\node[qa,below=of B] (D) {\scriptsize\qn{D:} \texttt{("a", "b")}};

		\draw[lw,short=-1pt] (A.east) to (B.west);
		\draw[lw,short=-1pt] (C.east) to (D.west);
	\end{tikzpicture}}
	\onslide<2->Wouldn't it be nice to have a lens that focuses on a specific element of
	a traversable container? Let's start with every element:
	\begin{haskell}
		§\onslide<5->§["Hello", "there"] §\onslide<3->§^.§\onslide<4->§ traverse §\onslide<8->\ergo~\texttt{"Hellothere"}§
	\end{haskell}\bigskip
	\onslide<9->Huh?! What's that? I would've expected \texttt{["Hello", "there"]}.\par
	\onslide<10->When viewing the result of \h{traverse}, it gets shoved through
	\h{mappend} first. \onslide<11->That's why you typically \h{^..}.
	% allOf (traverse . _2) even [(1,2),(3,4)] §\ergo~\texttt{True}§
	\begin{haskell}
		§\onslide<14->§[1..5] §\onslide<12->§^..§\onslide<13->§ traverse §\onslide<15->\ergo~\texttt{[1,2,3,4,5]}§
		§\onslide<16->§[(1,2),(3,4)] ^.. traverse . _2 §\onslide<17->\ergo~\texttt{[2,4]}§

		§\onslide<21->§[1..5] & §\onslide<19->§traverse §\onslide<18->§+~§\onslide<20->§ 1 §\onslide<22->\ergo~\texttt{[2,3,4,5,6]}§
	\end{haskell}\onslide<1->
	\mode<beamer>{\begin{modal}<6>
		\scalebox{0.9}{\usebox\wwm}
	\end{modal}}
	% \begin{modal}<2|handout:2>[Folds]
	% 	\begin{center}
	% 	\begin{tabular}{lll}
	% 		\hn{allOf} & \hn{anyOf} & \hn{noneOf}\\
	% 		\hn{sumOf} & \hn{productOf} & \hn{lengthOf}\\
	% 		\hn{concatOf} & \hn{elemOf} & \hn{notElemOf}\\
	% 		\hn{maximumOf} & \hn{minimumOf} & \hn{findOf}
	% 	\end{tabular}
	% 	\end{center}\medskip
	% 	You see the pattern, just append \hn{Of} to the function name, and tadaa, here's
	% 	your new fold that works with lenses.
	% \end{modal}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Traversals}
	As promised, here's how we can focus on a specific element of a traversable:
	\begin{haskell}
		[1..5] ^.. ix 1 §\ergo~\texttt{[2]}§
		[1..5] ^.. ix 5 §\ergo~\texttt{[]}§
	\end{haskell}\bigskip
	Returning an empty list on failure does not seem very nice. Let's use the
	prism-view-operator to get a \h{Maybe}:\par
	\begin{haskell}
		[1..5] ^? ix 1 §\ergo~\texttt{Just 2}§
		[1..5] ^? ix 5 §\ergo~\texttt{Nothing}§
	\end{haskell}
\end{frame}

\subsection{Isos}
\begin{frame}
	\frametitle{Isos}
	\onslide<2->Here's a very short summary:
	\begin{itemize}[<+(2)->]
		\item An \h{Iso} is a connection between two types that are equivalent in every way
		\item Isos should follow the following laws:\par
			\hn{forward . backward = id}\par
			\hn{backward . forward = id}
		\item We can write our own \h{Iso} by providing a forward and backward mapping
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Isos}
	\begin{haskell}
		§\onslide<2->§maybeToEither = maybe (Left ()) Right
		§\onslide<3->§eitherToMaybe = either (const Nothing) Just

		§\onslide<4->§someIso :: Iso' (Maybe a) (Either () a)
		§\onslide<5->§someIso = iso §\onslide<6->§maybeToEither §\onslide<7->§eitherToMaybe

		§\onslide<10->§Just "hi" §\onslide<8->§^. §\onslide<9->§someIso §\onslide<11->\ergo~\texttt{Right "hi"}§
		§\onslide<12->§Left "ho" ^. from someIso §\onslide<13->\ergo~\texttt{Nothing}§
	\end{haskell}
\end{frame}

\section{Summary}
\tikzset{
	u/.style={roundednode,draw=none,shadow,fill=gray!20},
	% u/.style={roundednode,fill=gray!20},
	v/.style={arrows={-Stealth[round,inset=0pt,length=10pt,angle'=90,open]},lw,lcr,rnd},
}
\def\card#1#2{\begin{tikzpicture}[node distance=0]
	\node[text width=0.45\textwidth] (C) {#2};
	\node[above=of C,yshift=-2mm] (T) {#1};
	\node[u,fit=(T)(C),node on layer=background] () {};
\end{tikzpicture}}
\begin{frame}
	\frametitle{Summary}
	\begin{wide}
		\begin{tikzpicture}
			\node (L) {\card{Lens}{\begin{itemize}
				\item Focus on a single part of a data structure
				\item \hn{^.} returns the focused part directly
			\end{itemize}}};
			\node[right=of L] (P) {\card{Prism}{\begin{itemize}
				\item Focus on a single part that may not exist
				\item \hn{^?} returns the focused part inside a \hn{Maybe}
			\end{itemize}}};
			\coordinate (A) at ($(L)!.5!(P)$);
			\coordinate (M) at (A |- L.north);
			\node[above=of M] (T) {\card{Traversals}{\begin{itemize}
				\item Focus on multiple parts (also zero) of a data structure
				\item \hn{^..} returns list of the focused parts
			\end{itemize}}};
			\draw[v] (L) to (T);
			\draw[v] (P) to (T);
		\end{tikzpicture}
	\end{wide}
\end{frame}

\definecolor{dblue}{HTML}{000742}
\newsavebox\duckforscale\newsavebox\sunb
\savebox\duckforscale{\tikz\duck[peakedcap=dblue];}
\makeatletter
\savebox\sunb{\begin{tikzpicture}
	\filldraw[draw=orange,fill=yellow,line width=6.6\smile@linewidth] (5,0) arc (0:360:5);
	\foreach\angle in {0,45,...,360}{
		\filldraw[draw=orange,fill=yellow,line width=5\smile@linewidth,rotate around={\angle:(0,0)}]
			(5.5,0) -- +(0,-1.5) -- +(3,0) -- +(0,1.5) -- cycle;
	}
\end{tikzpicture}}
\begingroup
\colorlet{accent}{dblue}
\setbeamercolor{footline}{fg=white,bg=dblue}
\setbeamercolor{footlineright}{bg=yellow}
\begin{frame}
	\frametitle{And so much more}
	\begin{wide}\centering
	\begin{tikzpicture}[o,every node/.append style={execute at begin node=\scriptsize}]
		\fill[shade,top color=white,bottom color=dblue] (current page.west) rectangle (current page.south east);
		\filldraw[decoration={random steps,segment length=3mm,amplitude=1mm},decorate,
			rnd,lw,draw=dblue,
			shade,top color=white,bottom color=dblue!50,middle color=dblue!15
		] (0,-3.5) -- (-3,0) -- (0,2) -- (3,0) -- (0,-3.5);
		\draw[dblue,decorate,decoration={snake,amplitude=1mm,segment length=2cm},lw] let \p1=(current page.west) in (\x1,0) -- (-3,0);
		\draw[dblue,decorate,decoration={snake,amplitude=1mm,segment length=2cm},lw] let \p1=(current page.east) in (3,0) -- (\x1,0);

		\node at (4.5,0.07) {\rotatebox{-15}{\scalebox{.15}{\usebox\duckforscale}}};
		\node[anchor=north east] at (current page.north east) {\scalebox{.15}{\usebox\sunb}};

		\node at (0,1.2) {General idea};
		\node at (1,0.5) {Lens laws};
		\node[text width=2cm,align=center] at (-0.9,0.5) {Composable lenses};
		\node at (0.3,0) {\hn{Lens}};
		\node at (-1.4,-0.2) {\hn{Prism}};
		\node[text width=11ex,align=center] at (1.5,-0.5) {\hn{Traversal}};
		\node at (0,-0.6) {\hn{Fold}};
		\node at (-1,-0.65) {\hn{Iso}};
		\node[text width=1.7cm,align=center] at (-0.9,-1.2) {Index\\preserving};
		\node at (0.8,-1) {\hn{Bazaar}};
		\node at (0.4,-1.7) {Subtyping};
		\node[text width=9ex,align=center] at (0,-2.3) {Typesignatures};
	\end{tikzpicture}
	\end{wide}
\end{frame}
\endgroup

\section{References}
\defbibheading{bibliography}[\bibname]{}

\begin{frame}[allowframebreaks]
	\frametitle{Reading suggestions}
	\printbibliography[keyword={suggestion}]
\end{frame}

\begin{frame}[allowframebreaks]
	\frametitle{References}
	\printbibliography
\end{frame}
\end{document}
